plugins {
    id "java-gradle-plugin"
    id "maven-publish"
    id "idea"
    id "jacoco"
    id "com.gradle.plugin-publish" version "1.1.0"
    id 'org.ajoberstar.reckon' version "0.16.1"
    id 'com.github.johnrengelman.shadow' version '7.1.2' apply false
    id "org.sonarqube" version "3.5.0.2730"
    id "be.vbgn.ci-detect" version "0.5.0"
}

import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import com.github.jengelman.gradle.plugins.shadow.tasks.ConfigureShadowRelocation

group 'eu.xenit.gradle'

sourceCompatibility = 1.8

configurations {
    packaged
    compileOnly.extendsFrom(packaged)
    testImplementation.extendsFrom(packaged)
    integrationTestImplementation.extendsFrom testImplementation
}

sourceSets {
    main {
        java {
            runtimeClasspath += configurations.packaged
        }
    }
    integrationTest {
        java {
            compileClasspath += main.output
            runtimeClasspath += main.output
        }
    }
}

idea {
    module {
        testSourceDirs += sourceSets.integrationTest.java.sourceDirectories
        testResourceDirs += sourceSets.integrationTest.resources.srcDirs
    }
}


gradlePlugin {
    plugins {
        dockerAlfresco {
            id = "eu.xenit.docker-alfresco"
            implementationClass = "eu.xenit.gradle.docker.alfresco.DockerAlfrescoPlugin"
            description = "Plugin that facilitates the creation of docker images for Alfresco and Share with custom modules"
        }
        dockerConfig {
            id = "eu.xenit.docker-config"
            implementationClass = "eu.xenit.gradle.docker.config.DockerConfigPlugin"
            description = "Plugin that configures the communication with the docker daemon and registries"
        }
        docker {
            id = "eu.xenit.docker"
            implementationClass = "eu.xenit.gradle.docker.core.DockerPlugin"
            description = "Plugin that enables you to build docker images"
        }
        dockerCompose {
            id = "eu.xenit.docker-compose"
            implementationClass = "eu.xenit.gradle.docker.compose.DockerComposePlugin"
            description = "Plugin that enables running docker-compose setups from Gradle"
        }
        dockerComposeAuto {
            id = "eu.xenit.docker-compose.auto"
            implementationClass = "eu.xenit.gradle.docker.compose.DockerComposeAutoPlugin"
            description = "This plugin is an extension of eu.xenit.docker-compose that automatically uses dockerCompose.fromProject() for all projects in your Gradle build."
        }
    }
    testSourceSets(sourceSets.test, sourceSets.integrationTest)
}

gradlePlugin {
    vcsUrl = "https://github.com/xenit-eu/alfresco-docker-gradle-plugin"
    website = vcsUrl
    description = "A gradle plugin to create Alfresco docker images with extensions"
    plugins {
        dockerAlfresco {
            displayName = "Alfresco docker plugin"
            tags.set(["alfresco", "docker"])
        }

        dockerConfig {
            displayName = "Docker configuration plugin"
            tags.set(["alfresco", "docker"])
        }

        docker {
            displayName = "Docker plugin"
            tags.set(["alfresco", "docker"])
        }

        dockerCompose {
            displayName = "docker-compose plugin"
            tags.set(["alfresco", "docker"])
        }

        dockerComposeAuto {
            displayName = "docker-compose plugin: automatic configuration for all projects"
            tags.set(["alfresco", "docker"])
        }
    }

}

reckon {
    scopeFromProp()
    snapshotFromProp()
}

repositories {
    mavenCentral()
    gradlePluginPortal()
    maven {
        url "https://artifacts.alfresco.com/nexus/content/groups/public/"
    }
}


dependencies {
    packaged 'org.alfresco:alfresco-mmt:6.0'
    packaged group: 'commons-io', name: 'commons-io', version: '2.11.0'
    packaged('org.eclipse.jgit:org.eclipse.jgit:6.4.0.202211300538-r') {
        exclude group: 'org.slf4j'
    }

    implementation 'com.bmuschko:gradle-docker-plugin:9.2.1'
    implementation 'com.avast.gradle:gradle-docker-compose-plugin:0.16.11'
    testImplementation group: 'junit', name: 'junit', version: '4.13.2'
    testImplementation 'org.hamcrest:hamcrest-core:2.2'
    testImplementation gradleTestKit()
    testImplementation "org.mockito:mockito-core:5.+"
    testImplementation 'com.github.stefanbirkner:system-rules:1.19.0'
}


task shadowJar(type: ShadowJar) {
    from sourceSets.main.output
    configurations = [project.configurations.packaged]
    archiveClassifier = "shadow"
    mergeServiceFiles()
    exclude "META-INF/*.SF"
    exclude "META-INF/*.RSA"
}

task configureShadowJar(type: ConfigureShadowRelocation) {
    target = shadowJar
    prefix = "eu.xenit.gradle.docker.internal.shadow"
}

shadowJar.dependsOn(configureShadowJar)

jar {
    from zipTree(shadowJar.outputs.files.singleFile)
    dependsOn(shadowJar)
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

pluginUnderTestMetadata {
    pluginClasspath.from(configurations.packaged)
}

import org.gradle.util.GradleVersion

task integrationTest(type: Test, group: "verification") {
    useJUnit()
    if (project.hasProperty("integrationTestGradleVersions")) {
        // This is used for sharding integration tests across different gradle versions
        // to avoid a timeout on travis because the total build takes too long.
        // See also the .travis.yml file
        project.property("integrationTestGradleVersions").tokenize(",").forEach({ version ->
            // The versions specified in `integrationTestGradleVersions` are major.minor.
            // We only want it to match those, and eventual patches to those versions.
            // In particular, we want 4.1 to match 4.1.2, but not 4.10.
            // Since there is only one test parameter for every version, either the first
            // pattern matches major.minor, or the second pattern matches major.minor.patch
            filter.includeTestsMatching("*[Gradle v${version}]")
            filter.includeTestsMatching("*[Gradle v${version}.*]")
        })
    }
    doFirst {
        if (gradle.startParameter.offline) {
            systemProperty "eu.xenit.gradle.integration.useGradleVersion", GradleVersion.current().version
        }
    }
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    shouldRunAfter(test)
}

jacocoTestReport {
    dependsOn(test, integrationTest)
    executionData(test, integrationTest)
    reports {
        xml.enabled = true
    }
}

sonarqube {
    properties {
        properties["sonar.tests"] += sourceSets.integrationTest.java.srcDirs
        if (ci.isPullRequest()) {
            properties["sonar.pullrequest.key"] = ci.pullRequest
            properties["sonar.pullrequest.branch"] = ci.branch
            properties["sonar.pullrequest.base"] = ci.pullRequestTargetBranch
        } else {
            properties["sonar.branch.name"] = ci.reference
        }
    }
}

check.dependsOn(integrationTest)
reckonTagCreate.dependsOn(check)
tasks.sonarqube.dependsOn(check, jacocoTestReport)

